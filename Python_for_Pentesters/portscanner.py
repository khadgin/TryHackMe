#! /usr/bin/env python3

import ipaddress
import socket
import sys

def is_port_open(ip: str, port: int, timeout=1.0, verbose=False):
    """is_port_open: Test if a given portnumber is open or not.
      Arguments:
        ip (str)        : The IP address to scan.
        port (int)      : The port to check.
        timeout (float) : The timeout of the socket in seconds.
                          Default: 1.0
        verbose (bool)  : If True, print verbose output to STDERR.
      Return value:
        is_open (bool)  : True if the port is open, False otherwise,
                          None is an unrelated exception occured.
    """
    try:
        ip = ipaddress.ip_address(ip)
    except TypeError as e:
        if verbose:
            print(f'"{ip}": Not a valid IPv4 or IPv6 address.',
                  file=sys.stderr)
            raise e;
    if ip.version == 4:
        socket_type = socket.AF_INET
    elif ip.version == 6:
        socket_type = socket.AF_INET6
    else:
        if verbose:
            print(f'Unknown IP version: {ip.version}.',
                  file=sys.stderr)
        raise ValueError(f'Unknown IP version: {ip.version}.')
    s = socket.socket(socket_type, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        result = s.connect_ex((ip.exploded, port))
        if result == 0:
            if verbose:
                print(f'[+] {ip.exploded}:{port} is open',
                      file=sys.stderr)
            is_open = True
        else:
            if verbose:
                print(f'[-] {ip.exploded}:{port} is closed',
                      file=sys.stderr)
            is_open = False
    except Exception as e:
        if verbose:
            print(f'[!] {ip.exploded}:{port} Exception "{e}" occured.',
                  'Port status unknown.', file=sys.stderr)
        is_open = None
    finally:
        s.close()
        return is_open
# end is_port_open

def parse_ports(ports_str):
    '''parse_ports: Parse a string which contains comma-separated
        ports or port ranges and returns all ports as a list.
        Arguments:
          ports_str (str) : Comma-separated list of ports/port ranges.
                            Ranges are indicated by hyphens.
        Return values:
          ports (set)     : All ports parsed into a set.
    '''
    raw_list = ports_str.split(',')
    ports = set()
    for elem in raw_list:
        if '-' in elem:
            start, stop = elem.split('-')
            start = int(start)
            stop = int(stop)
            for port in range(start, stop+1):
                ports.add(port)
        else:
            ports.add(int(elem))
    return ports
# end parse_ports

def parse_ip_str(ip_str: str):
    '''parse_ip_str: Parse a string which contains comma-separated
        IP addresses or networks in CIDR notation and returns all
        resulting IP addresses as a list.
        Arguments:
          ip_str (str)  : Comma-separated list of IP addresses or
                            networks in CIDR notation.
        Return values:
          ips (set)     : All IP addresses parsed into a set.
    '''
    raw_list = ip_str.split(',')
    ips = set()
    for item in raw_list:
        if '/' in item:
            net = ipaddress.ip_network(item, strict=False)
            for ip in net.hosts():
                ips.add(ip.exploded)
        else:
            ip = ipaddress.ip_address(item)
            ips.add(ip.exploded)
    return ips
# end parse_ip_str

def parse_ip_file(ip_file):
    '''parse_ip_file: Parse a file which contains one IP address or
        network in CIDR notation per line and returns all
        resulting IP addresses as a list.
        Arguments:
          ip_file (file descriptor) : The file to parse
        Return values:
          ips (set)     : All IP addresses parsed into a set.
    '''
    ips = set()
    for line in ip_file.readlines():
        line = line.strip()
        if '/' in line:
            net = ipaddress.ip_network(line, strict=False)
            for ip in net.hosts():
                ips.add(ip.exploded)
        else:
            ip = ipaddress.ip_address(line)
            ips.add(ip.exploded)
    return ips
# end parse_ip_file

if __name__ == '__main__':
    import argparse
    import concurrent.futures
    import csv
    parser = argparse.ArgumentParser()
    parser.add_argument('--ports', '-p', default='1-1023',
                        help='A comma separated list of ports to scan.'
                        ' Ranges can be given using a hyphen; e.g.'
                        ' "80,100-222,445,3389-4000". Default: 1-1023')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Provide more verbose output.')
    parser.add_argument('--ipfile', '-i', type=argparse.FileType('r'),
                        help='File with IP addresses or networks to'
                        'scan. One address/network per line. These'
                        ' will be merged with any IP addresses/networks'
                        ' provided on the commandline')
    parser.add_argument('--timeout', '-t', type=float, default=1.0,
                        help='Timeout on the socket in seconds.'
                        'Default: 1.0')
    parser.add_argument('--outfile', '-o', default='-',
                        help='The file to write the results to.'
                        ' Default: STDOUT.')
    parser.add_argument('--threads', type=int, default=1000,
                        help='Number of connections started at once.'
                        ' Default: 1000')
    parser.add_argument('iplist', nargs='?', help='Comma-separated'
                        ' list of IP addresses to scan. It is possible'
                        ' to provide networks in CIDR notation.'
                        ' Networks and IP addresses can be mixed.')
    args = parser.parse_args()
    ports_to_scan = parse_ports(args.ports)
    ips_to_scan = set()
    if args.iplist:
        ips_to_scan = parse_ip_str(args.iplist)
    if args.ipfile:
        ips_from_file = parse_ip_file(args.ipfile)
        ips_to_scan = ips_to_scan.union(ips_from_file)
    if len(ips_to_scan) == 0:
        print('No IP addresses provided. Exiting.', file=sys.stderr)
        sys.exit(1)
    open_ports_by_ip = list()
    for ip in ips_to_scan:
        with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:
            future_to_port = {executor.submit(is_port_open, ip, port, args.timeout, args.verbose): port for port in ports_to_scan}
            for future in concurrent.futures.as_completed(future_to_port):
                port = future_to_port[future]
                if future.result():
                    open_ports_by_ip.append([ip, port])
    if args.outfile == '-':
        for ip_port_pair in open_ports_by_ip:
            print(f'"{ip_port_pair[0]}","{ip_port_pair[1]}"')
    else:
        with open(args.outfile, 'w') as fd:
            writer = csv.writer(fd, dialect='unix', quoting=csv.QUOTE_ALL)
            writer.writerows(open_ports_by_ip)

