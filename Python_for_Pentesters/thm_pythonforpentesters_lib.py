import ipaddress
import paramiko
import socket
import sys

def parse_ports(ports_str):
    '''parse_ports: Parse a string which contains comma-separated
        ports or port ranges and returns all ports as a list.
        Arguments:
          ports_str (str) : Comma-separated list of ports/port ranges.
                            Ranges are indicated by hyphens.
        Return values:
          ports (set)     : All ports parsed into a set.
    '''
    raw_list = ports_str.split(',')
    ports = set()
    for elem in raw_list:
        if '-' in elem:
            start, stop = elem.split('-')
            start = int(start)
            stop = int(stop)
            for port in range(start, stop+1):
                ports.add(port)
        else:
            ports.add(int(elem))
    return ports
# end parse_ports

def parse_ip_str(ip_str: str):
    '''parse_ip_str: Parse a string which contains comma-separated
        IP addresses or networks in CIDR notation and returns all
        resulting IP addresses as a list.
        Arguments:
          ip_str (str)  : Comma-separated list of IP addresses or
                            networks in CIDR notation.
        Return values:
          ips (set)     : All IP addresses parsed into a set.
    '''
    raw_list = ip_str.split(',')
    ips = set()
    for item in raw_list:
        if '/' in item:
            net = ipaddress.ip_network(item, strict=False)
            for ip in net.hosts():
                ips.add(ip.exploded)
        else:
            ip = ipaddress.ip_address(item)
            ips.add(ip.exploded)
    return ips
# end parse_ip_str

def parse_ip_file(ip_file):
    '''parse_ip_file: Parse a file which contains one IP address or
        network in CIDR notation per line and returns all
        resulting IP addresses as a list.
        Arguments:
          ip_file (file descriptor) : The file to parse
        Return values:
          ips (set)     : All IP addresses parsed into a set.
    '''
    ips = set()
    for line in ip_file.readlines():
        line = line.strip()
        if '/' in line:
            net = ipaddress.ip_network(line, strict=False)
            for ip in net.hosts():
                ips.add(ip.exploded)
        else:
            ip = ipaddress.ip_address(line)
            ips.add(ip.exploded)
    return ips
# end parse_ip_file

def parse_comma_separated_list(comma_separated_list):
    '''parse_comma_separated_list: Parse a string consisting of a
      comma-separated list into a set.
      Arguments:
        comma_separated_list (str)  : This list to parse
      Return values:
        A set containing all unique values in the list.
    '''
    return set(comma_separated_list.split(','))
# end parse_comma_separated_list

def parse_file(fd):
    '''parse_file: Parse a file by taking each line as an entry for
        the set.
      Arguments:
        fd  : An open filedescriptor with the 'r' flag set.
      Return values:
        result_set (set)  : The resulting set containing each unique
                            line in the file as an element.
    '''
    result_set = set()
    for line in fd.readlines():
        line = line.strip()
        result_set.add(line)
    return result_set
# end parse_file

  
def is_port_open(ip: str, port: int, timeout=1.0, verbose=False):
    """is_port_open: Test if a given portnumber is open or not.
      Arguments:
        ip (str)        : The IP address to scan.
        port (int)      : The port to check.
        timeout (float) : The timeout of the socket in seconds.
                          Default: 1.0
        verbose (bool)  : If True, print verbose output to STDERR.
      Return value:
        is_open (bool)  : True if the port is open, False otherwise,
                          None is an unrelated exception occured.
    """
    try:
        ip = ipaddress.ip_address(ip)
    except TypeError as e:
        if verbose:
            print(f'"{ip}": Not a valid IPv4 or IPv6 address.',
                  file=sys.stderr)
            raise e;
    if ip.version == 4:
        socket_type = socket.AF_INET
    elif ip.version == 6:
        socket_type = socket.AF_INET6
    else:
        if verbose:
            print(f'Unknown IP version: {ip.version}.',
                  file=sys.stderr)
        raise ValueError(f'Unknown IP version: {ip.version}.')
    s = socket.socket(socket_type, socket.SOCK_STREAM)
    s.settimeout(timeout)
    try:
        result = s.connect_ex((ip.exploded, port))
        if result == 0:
            if verbose:
                print(f'[+] {ip.exploded}:{port} is open',
                      file=sys.stderr)
            is_open = True
        else:
            if verbose:
                print(f'[-] {ip.exploded}:{port} is closed',
                      file=sys.stderr)
            is_open = False
    except Exception as e:
        if verbose:
            print(f'[!] {ip.exploded}:{port} Exception "{e}" occured.',
                  'Port status unknown.', file=sys.stderr)
        is_open = None
    finally:
        s.close()
        return is_open
# end is_port_open

def are_ssh_credentials_valid(username: str, password: str,
                              host: str, port=22, verbose=False):
    '''is_ssh_password_valid: Try if a given username:password pair
          is valid on a given SSH server running on the given port.
       Arguments:
        username  (str) : The username to check.
        password  (str) : The password to check in plaintext.
        host      (str) : The host to connect to.
        port      (int) : The port SSH is listening on.
        verbose   (bool): Print verbose output.
       Return values:
        True  :  The credentials are valid.
        False : Otherwise
    '''
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    is_valid = None
    try:
        ssh_client.connect( host, port=port,
                            username=username, password=password)
        is_valid = True
    except paramiko.AuthenticationException:
        is_valid = False
    finally:
        ssh_client.close()
        return is_valid
# end are_ssh_credentials_valid        
